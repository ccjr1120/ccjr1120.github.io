---
title: 'WebGPU实现Game Of Life（2）：渲染Game Of Life'
excerpt: '本篇是《使用WebGPU API 实现Game Of Life》系列的第二篇，也是最后一篇。主要是为了完成Game Of Life的渲染'
date: '2025-07-23'
author: '匆匆孑然'
tags: [WebGPU]
---
## 游戏简介
Game of Life是由数学家约翰·康威（John Conway）在1970年发明的一种细胞自动机（cellular automaton）。它基于简单的规则，通过迭代生成复杂的模式。
#### 游戏设定
- 游戏在一个无限大的二维网格上进行，每个格子（细胞）有两种状态：存活（1）或死亡（0）。
- 每个细胞有八个邻居（周围的八个格子）。
- 游戏以时间步长（代）推进，每一代根据以下规则更新所有细胞状态。
#### 游戏规则
- 一个存活的细胞（状态为1）：
  - 如果它有 2 或 3 个存活的邻居，它在下一代继续存活。
  - 否则（少于2个或多于3个存活邻居），它因“孤独”或“拥挤”而死亡（变为0）。
- 死亡规则：一个死亡的细胞（状态为0）：
  - 如果它恰好有 3 个存活的邻居，它会在下一代复活（变为1）。
  - 否则，它保持死亡状态。
- 同步更新：所有细胞的状态在每一代同时更新，基于当前代的邻居情况。
## Game Of Life1.0
我觉得直接使用WebGPU的计算着色器去实现游戏规则可能会有点难以理解，所以我准备出两个版本，第一个版本是TS计算GPU渲染；第二个版本是如何使用将TS计算的部分放到计算着色器中的。
下面我们分几步来完成这个游戏。
### 实现一个单细胞对象，让他根据游戏规则完成自身状态的更新。
```ts
class Monad {
  index: number = 0
  state: typeof CELL_STATE.DEAD | typeof CELL_STATE.LIVE = CELL_STATE.DEAD
  constructor(index: number) {
    this.index = index
  }
  /**
   * 获取当前细胞的邻居索引（假设一维数组，二维网格，边界不越界）
   * @param cols 列数
   * @param rows 行数
   */
  getNeighborIndices(cols: number, rows: number): number[] {
    const neighbors: number[] = []
    const x = this.index % cols
    const y = Math.floor(this.index / cols)
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue
        const nx = x + dx
        const ny = y + dy
        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
          neighbors.push(ny * cols + nx)
        }
      }
    }
    return neighbors
  }

  /**
   * 根据邻居状态更新自身状态
   * @param cells 所有细胞对象的数组
   * @param cols 列数
   * @param rows 行数
   */
  updateState(cells: Monad[]) {
    const cols = GRID_SIZE
    const rows = GRID_SIZE
    const neighborIndices = this.getNeighborIndices(cols, rows)
    let liveCount = 0
    for (const idx of neighborIndices) {
      if (cells[idx].state === 1) liveCount++
    }
    if (this.state === 1) {
      // 存活细胞
      if (liveCount === 2 || liveCount === 3) {
        this.state = 1
      } else {
        this.state = 0
      }
    } else {
      // 死亡细胞
      if (liveCount === 3) {
        this.state = 1
      } else {
        this.state = 0
      }
    }
  }
}
```
### 建立一个细胞集合， 通过RAF来完成细胞状态的更新。
```ts
 useEffect(() => {
    let animationId: number

    const animate = () => {
      // 更新所有细胞状态
      cells.forEach((cell) => {
        cell.updateState(cells)
      })

      console.log('Updated cells:', cells)

      // 继续下一帧
      animationId = requestAnimationFrame(animate)
    }

    // 启动动画
    animationId = requestAnimationFrame(animate)

    // 清理函数
    return () => {
      if (animationId) {
        cancelAnimationFrame(animationId)
      }
    }
  })
```
### 在WebGL中渲染N*N个单元格用来表示细胞实体。
在上文中，我们在WebGPU中渲染了一个正方形。接下来，我们需要渲染大量的正方形来表示细胞实体。接下来我们有两个方式：一种是按照渲染一个的方法，提供大量的点去渲染所有的正方形；一种是提供一个正方形的顶点，渲染足够多的实体，然后通过每个实体的下标通过简单的算法在着色器来控制每个实体的渲染。我相信以大部分人的直觉而言，第二种方式更加优雅。所以我会使用第二种方式来渲染。
1. 首先，我们需要调整渲染实体的数量
```ts
pass.draw(vertices.length / 2, GRID_SIZE * GRID_SIZE)
```
在`draw`中，第一个参数是顶点的数量，第二个参数是每个顶点需要绘制的次数。这时候我们要GPU中渲染了`GRID_SIZE * GRID_SIZE`个正方形。

2. 接着我们需要使用顶点着色器以及实体的下标来控制每个实体的渲染位置
```bash
@vertex
fn vertexMain(@location(0) pos : vec2f,
@builtin(instance_index) instance : u32) ->
@builtin(position) vec4f {

  let grid = vec2f(32.0, 32.0);
  let i = f32(instance);
  //Compute the cell coordinate from the instance_index
  let cell = vec2f(i % grid.x, floor(i / grid.x));

  let cellOffset = cell / grid * 2;
  let gridPos = (pos + 1) / grid - 1 + cellOffset;

  return vec4f(gridPos, 0, 1);
}
```
在这里，我们根据网格数`32.0`来按比例缩放顶点坐标，然后根据[一连串的坐标换算](https://codelabs.developers.google.com/your-first-webgpu-app?hl=zh-cn#4)，将每个实体的顶点坐标映射到每个单元格的范围内。

import DemoGrid from './demo-grid'

<DemoGrid />

3. 接下来我们要做的就简单了，我们只需要在片元着色器中根据每个实体的状态来决定每个实体的颜色。存活的为蓝色，死亡的为透明色。唯一的问题就是，我们如何将每个实体的状态传递给片元着色器。于是，我们就有了一个新概念：`uniform`。

在WebGPU中，除了顶点缓冲区，还有uniform 缓冲区。下面我来创建一个uniform 缓冲区，并将其传递给片元着色器。
```ts
const uniformArray = new Float32Array(GRID_SIZE * GRID_SIZE * 4)

for (let i = 0; i < cells.length; i++) {
  const offset = i * 4
  uniformArray[offset + 0] = cells[i].state // 存活状态 (0.0 或 1.0)
  uniformArray[offset + 1] = 0.0 // 补位
  uniformArray[offset + 2] = 0.0 // 补位
  uniformArray[offset + 3] = 0.0 // 补位
}
const uniformBuffer = device.createBuffer({
  label: 'Grid Uniforms',
  size: uniformArray.byteLength,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
})
device.queue.writeBuffer(uniformBuffer, 0, uniformArray)
const bindGroup = device.createBindGroup({
  label: "Cell renderer bind group",
  layout: cellPipeline.getBindGroupLayout(0),
  entries: [{
    binding: 0,
    resource: { buffer: uniformBuffer }
  }],
});
pass.setBindGroup(0, bindGroup);

// 在着色器中添加的代码
@group(0) @binding(0) var<uniform> cells : array<vec4f, 1024>;
```
在上面的代码中，我们通过`pass.setBindGroup`和`binding: 0`将uniform 缓冲区绑定到着色器中。同时绑定位为`0`。在着色器中通过`@group(0) @binding(0) var<uniform> cells : array<vec4f, 1024>;`来获取uniform 缓冲区。
之后我们通过`instance_index`来获取每个实体的状态，然后赋值不同的颜色。完整的着色器代码如下：
```ts
struct VertexOutput {
  @builtin(position) pos : vec4f,
  @location(0) color : vec4f,
}

@group(0) @binding(0) var<uniform> cells : array<vec4f, 1024>;
@vertex
fn vertexMain(@location(0) pos : vec2f,
@builtin(instance_index) instance : u32) -> VertexOutput {

  let grid = vec2f(32.0, 32.0);
  let i = f32(instance);

  //计算单元格坐标
  let cell = vec2f(i % grid.x, floor(i / grid.x));

  //计算位置偏移
  let cellOffset = cell / grid * 2.0 - 1.0;
  let gridPos = pos * 0.8 + cellOffset;

  //使用 instance_index 查找对应的状态
  let cellState = cells[instance];

  var color = vec4f(0.0, 0.0, 0.0, 1.0);

  if (cellState.x > 0.5)
  {
    //存活状态 - 绿色系
    color = vec4f(0.2, 0.8, 0.3, cellState.w);
  } else {
    //死亡状态 - 红色系
    color = vec4f(0.8, 0.2, 0.2, cellState.w * 0.3);
  }



  return VertexOutput(vec4f(gridPos, 0, 1), color);
}

@fragment
fn fragmentMain(input : VertexOutput) -> @location(0) vec4f {
  return input.color;
}
```
在着色器代码中，除了之前讲到的还涉及到了`顶点着色器给片元着色器传递传参`和`结构体类型`。接下来我们只需要添加一个RAF函数更新细胞状态，然后重新运行渲染函数即可。

import DemoUniform from './demo-uniform'

<DemoUniform />


### 使用计算着色器实现Game Of Life
在上文中，我们使用了JS去计算，uniform去传递细胞状态。这次我们试试更方便的storage buffer，以及比JS计算更好的计算着色器。
### 创建Storage Buffer传递细胞状态
```ts
const cellStateArray = new Uint32Array(GRID_SIZE * GRID_SIZE);


const storageBuffer = device.createBuffer({
  label: 'Grid Storage',
  size: cells.length * 4,
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
})

```

### 创建计算着色器
```ts
const simulationShaderModule = device.createShaderModule({
  label: "Game of Life simulation shader",
  code: `
    @group(0) @binding(0) var<uniform> grid: vec2f;

    @group(0) @binding(1) var<storage> cellStateIn: array<u32>;
    @group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;

    fn cellIndex(cell: vec2u) -> u32 {
      return cell.y * u32(grid.x) + cell.x;
    }

    fn cellActive(x: u32, y: u32) -> u32 {
      return cellStateIn[cellIndex(vec2(x, y))];
    }


    @compute @workgroup_size(8, 8)
    fn computeMain(@builtin(global_invocation_id) cell: vec3u) {
      if (cellStateIn[cellIndex(cell.xy)] == 1) {
        cellStateOut[cellIndex(cell.xy)] = 0;
      } else {
        cellStateOut[cellIndex(cell.xy)] = 1;
      }
    }`
});
```

import DemoComputed from './demo-computed'

<DemoComputed />