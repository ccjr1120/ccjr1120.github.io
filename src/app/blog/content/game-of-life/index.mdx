---
title: 'WebGPU实现Game Of Life'
excerpt: '使用WebGPU API 实现Game Of Life，了解WebGPU API的概念以及使用方法'
date: '2025-07-23'
author: '匆匆孑然'
tags: [WebGPU]
---


## Conway's Game of Life

import Demo from './demo'

<Demo />
##  WebGPU渲染步骤
&emsp;&emsp;就像Google的教程[你的第一个 WebGPU 应用
](https://codelabs.developers.google.com/your-first-webgpu-app?hl=zh-cn#0)一样，我会先使用一个简单的三角形来认识GPU的渲染步骤，了解适配器，渲染管道，Uniform等等概念
### 创建GPU上下文
```ts
if (!navigator.gpu) {
    console.error('WebGPU 不支持')
    return
}
const adapter = await navigator.gpu.requestAdapter()
if (!adapter) {
    console.error('无法获取 WebGPU 适配器')
    return
}
const device = await adapter.requestDevice()
const canvas = canvasRef.current!
const context = canvas.getContext('webgpu')
if (!context) {
    console.error('无法获取 WebGPU 上下文')
    return
}
const canvasFormat = navigator.gpu.getPreferredCanvasFormat()
context.configure({
    device: device,
    format: canvasFormat
})
```
&emsp;&emsp;在上下文这里一共做了四件事：`检查浏览器是否支持WebGPU`，`获取GPU适配器`，`获取WebGpu上下文`，`配置WebGpu上下文`。当我想起2D和GL的时候，我就发现这里多做了两件事，那就是`获取GPU适配器`和`配置WebGpu上下文`。这时候就有了一个问题，为什么会多两件事，他们在做什么？

&emsp;&emsp;在谈这两件事之前，先说下WebGPU的其中一个设计理念：`一切都要显式配置`，这个不是很难理解，由于WebGPU就是在追求极致的性能体验。显式往往更好做针对性的优化。隐式虽然用起来感觉更智能，但是背后的成本更高以至于无法达成最好的效果。

&emsp;&emsp;而GPU适配器，在显式配置的目标下，他还多给了用户一个选择。如果你做过WebGL，你就经常会遇到客户的配置并不算差，但是格外卡顿的事情。往往结论也是客户没有在使用独显而是在用核显。WebGPU就给了你这么一个机会，让你自己去选择GPU。在`navigator.gpu.requestAdapter()`中，你可以传入一些参数来获取最适合你的GPU。比如：`navigator.gpu.requestAdapter({powerPreference: 'high-performance'})`，这样就会优先选择性能更好的GPU。   

&emsp;&emsp;至于剩下的一件事：`CanvasFormat`，我现在对它的了解也不是很清晰。它指的是像素和纹理数据的存储格式。简而言之就是它描述你屏幕中每个点的色彩的存储格式。比起WebGL，WebGPU更希望明确这些格式，来更好的预测渲染结果，从而更好的进行优化。返回值通常是`bgra8unorm`，它表示每个像素使用8位无符号整数来存储蓝、绿、红和透明度四个通道。

### 创建GPU设备
### 创建GPU缓冲区
### 创建GPU纹理
### 创建GPU着色器
### 创建GPU渲染管线
### 创建GPU渲染通道
### 创建GPU渲染命令
### 创建GPU渲染队列