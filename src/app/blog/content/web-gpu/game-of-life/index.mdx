---
title: 'WebGPUå®ç°Game Of Life'
excerpt: 'é€šè¿‡å­¦ä¹ WebGPUçš„æ¸²æŸ“æµæ°´çº¿ï¼Œç€è‰²å™¨å®ç°Game Of Life'
date: '2025-08-26'
author: 'åŒ†åŒ†å­‘ç„¶'
tags: [WebGPU]
---
## æ•ˆæœå±•ç¤º
import Demo from './demo'

<Demo />
## å‰è¨€
æœ¬ç¯‡å¯ä»¥çœ‹ä½œæ•™ç¨‹[ã€Šæ‚¨çš„ç¬¬ä¸€ä¸ª WebGPU åº”ç”¨ã€‹](https://codelabs.developers.google.com/your-first-webgpu-app?hl=zh-cn#7)çš„æ€»ç»“ã€‚åœ¨æ­¤æ•™ç¨‹çš„åŸºç¡€ä¹‹ä¸Šï¼Œæ€»ç»“WebGPUæ¸²æŸ“çš„çŸ¥è¯†ç‚¹ï¼Œå¿«é€Ÿå®Œæˆä¸€ä¸ªGame Of Lifeæ¸¸æˆã€‚

è¿™ç¯‡æ–‡ç« ä¸€å…±ä¼šåˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªç« èŠ‚ï¼š`æ•°æ®`,`ç€è‰²å™¨`,`æ¸²æŸ“æµæ°´çº¿`ã€‚æ¯ç« éƒ½ä¼šç®€å•ä»‹ç»ä¸‹åŸºæœ¬æ¦‚å¿µï¼Œå…·ä½“ç”¨æ³•ï¼Œè¾¾æˆçš„ç›®æ ‡ã€‚æœ€åå†å°†è¿™äº›çŸ¥è¯†ç‚¹åˆå¹¶åˆ°Game Of Lifeçš„ä»£ç å®ç°ä¸­

## æ•°æ®
æ•°æ®æ˜¯ä¸€åˆ‡çš„åŸºç¡€ï¼Œåœ¨ä½¿ç”¨WebGPUæ¸²æŸ“ä¸­ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å¦‚ä½•å°†TSä¸­çš„æ•°æ®ä¼ é€’ç»™WebGPUä»¥åŠWebGPUå¦‚ä½•ä½¿ç”¨ã€‚ä½†æ˜¯åœ¨è¿™ä¹‹å‰ï¼Œå…ˆè®©æˆ‘ä»¬äº†è§£ä¸€ä¸‹æœ‰å“ªäº›æ•°æ®éœ€è¦ä¼ è¾“ã€‚
### ç±»å‹
#### é¡¶ç‚¹æ•°æ®
åœ¨ä»‹ç»é¡¶ç‚¹æ•°æ®ä¹‹å‰ï¼Œæˆ‘å¾ˆæƒ³å…ˆä»‹ç»ä¸€ä¸‹`TypedArray`ï¼Œå› ä¸ºä¸ç®¡WebGPUæœ‰å“ªäº›æ•°æ®ç±»å‹ï¼Œåœ¨JSä¸­ï¼Œä»–ä»¬éƒ½æ˜¯ä¸€ä¸ª`TypedArray`ã€‚ä¸è¿‡è¿™æ ·å¤ªè´¹ç« èŠ‚ï¼Œå†…å®¹ä¹Ÿä¼šå˜çš„è¶Šæ¥è¶Šæ­»æ¿ã€‚å¦‚æœä½ äº†è§£å®ƒï¼Œé‚£æœ€å¥½ï¼›å¦‚æœä¸äº†è§£ï¼Œå®ƒåªæ˜¯ä¸€ä¸ªæ•°æ®ç±»å‹è€Œå·²ï¼Œå°±åƒ`Stringã€Array`ä¸€æ ·ã€‚

ä¼—æ‰€å‘¨çŸ¥ï¼Œä½ åœ¨å±å¹•ä¸Šçœ‹åˆ°çš„ä¼—å¤šä¸œè¥¿éƒ½æ˜¯ç”±ä¸‰è§’å½¢ç»„æˆçš„ã€‚å³ä½¿ä½ æƒ³æ¸²æŸ“ä¸€ä¸ªæ­£æ–¹å½¢ï¼Œä¹Ÿæ˜¯é€šè¿‡æä¾›ä¸¤ä¸ªä¸‰è§’å½¢çš„é¡¶ç‚¹åæ ‡ï¼Œä»è€Œå½¢æˆä¸€ä¸ªæ­£æ–¹å½¢ã€‚åœ¨JSä¸­ï¼Œä»–å°±æ˜¯ä¸€ä¸ªå¹³é“º`x,y`çš„åæ ‡æ•°ç»„ã€‚åŒæ—¶ï¼ŒGPUçš„åæ ‡ç³»æ˜¯[-1,1]ï¼Œæ‰€ä»¥ä¸‹æ–¹æä¾›çš„åæ ‡ä¸ä¼šè¶…è¿‡è¿™ä¸ªå€¼ã€‚

```ts
const vertices = new Float32Array([
        -0.8, -0.8, 0.8, -0.8, 0.8, 0.8, -0.8, -0.8, 0.8, 0.8, -0.8, 0.8
])
```

ä¸ºä»€ä¹ˆæ²¡æœ‰zï¼Ÿå› ä¸ºç”¨ä¸åˆ°ã€‚
#### Uniformå’ŒStorage
Uniformå’ŒStorageæ˜¯ä¸¤ä¸ªæœ‰è¶£çš„ä¸œè¥¿ï¼Œé™¤äº†é¡¶ç‚¹åæ ‡ä¹‹å¤–ï¼Œç›®å‰æˆ‘çŸ¥é“çš„å°±åªæœ‰è¿™ä¸¤ä¸ªè´Ÿè´£ä»JSä¼ è¾“åˆ°GPUäº†ã€‚ä»ç„¶ï¼Œå®ƒä»¬åœ¨JSä¸­çš„è¡¨ç°éƒ½æ˜¯`TypedArray`ã€‚ä½†æ˜¯å®ƒä»¬åœ¨ç€è‰²å™¨ä¸­çš„è¡¨ç°æœ‰ç‚¹ä¸ä¸€æ ·ã€‚

Uniformæ˜¯ä¸€æ®µé™å®šå†…å­˜ï¼Œéœ€è¦åœ¨ç€è‰²å™¨ä¸­æŒ‡å®šå¤§å°çš„æ•°ç»„ã€‚ä»–ä»¬æ²¡åŠæ³•è¢«ç€è‰²å™¨ä¿®æ”¹ï¼Œåªèƒ½è¢«ç€è‰²å™¨è¯»å–ã€‚ä½†æ˜¯ç”±äºè¿™è¯¸å¤šä¸ä¾¿ï¼Œä¸€èˆ¬å®ƒä»¬åœ¨GPUä¸­ä¼šæ‹¥æœ‰é¢å¤–çš„æ€§èƒ½åŠ æˆã€‚

Storageå°±æ˜¯è‡ªç”±ï¼Œæ–¹ä¾¿çš„ä»£è¡¨ï¼Œæƒ³å­˜å°±å­˜ï¼Œæƒ³æ”¹å°±æ”¹ã€‚

### ä¼ è¾“
ä¼ è¾“çœŸçš„å¾ˆéº»çƒ¦ï¼Œè·¨è¶Šäº†JSä»¥åŠç€è‰²å™¨ï¼Œå®ƒä»¬å‡ ä¹éƒ½è¦æŒ‰ä»¥ä¸‹çš„æµç¨‹å»æ“ä½œï¼š
```ts
// 1.å£°æ˜ä¸€ä¸ªbuffer
const uniformBuffer = device.createBuffer({
        label: 'Grid Uniforms',
        size: uniformArray.byteLength,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
})
// 2.å°†æ•°æ®å†™å…¥buffer
device.queue.writeBuffer(uniformBuffer, 0, uniformArray)
// 3.å¦‚æœæƒ³è¦åœ¨ä¸åŒçš„ç€è‰²å™¨ä¸­å…±äº«bufferï¼Œè¿˜éœ€è¦ä¸ºå®ƒåˆ›å»ºå¯¹åº”çš„createPipelineLayout
  const bindGroupLayout = device.createBindGroupLayout({
        label: 'Cell Bind Group Layout',
        entries: [
          {
            binding: 0,
            visibility:
              GPUShaderStage.VERTEX |
              GPUShaderStage.COMPUTE |
              GPUShaderStage.FRAGMENT,
            buffer: {} // Grid uniform buffer
          }
        ]
      })
      const bindGroups = [
        device.createBindGroup({
          label: 'Cell renderer bind group A',
          layout: bindGroupLayout, // Updated Line
          entries: [
            {
              binding: 0,
              resource: { buffer: uniformBuffer }
            }
          ]
        }),
        device.createBindGroup({
          label: 'Cell renderer bind group B',
          layout: bindGroupLayout, // Updated Line
          entries: [
            {
              binding: 0,
              resource: { buffer: uniformBuffer }
            }
          ]
        })
      ]
      const pipelineLayout = device.createPipelineLayout({
        label: 'Cell Pipeline Layout',
        bindGroupLayouts: [bindGroupLayout]
      })
// 4. æœ€åï¼Œåœ¨ç€è‰²å™¨ä¸­è¿™æ ·ä½¿ç”¨å®ƒ
`@group(0) @binding(0) var<uniform> grid : vec2f;`
```

è‡³æ­¤æ‰ç»“æŸï¼Œå¦‚æœå†åŠ ä¸ŠStorageBufferï¼Œé‚£ä¹ˆè¿™ä¸€æ®µçš„ä»£ç é‡å°±å¾ˆå¤šäº†ã€‚ä½†æ˜¯å½“ä½ ç†è§£çš„æ—¶å€™ï¼Œå®ƒä»¬å°±åƒä¸€æ¡æµæ°´çº¿ä¸€æ ·åšä¸‹æ¥å°±å¯ä»¥äº†ã€‚å¤§éƒ¨åˆ†äººçœ‹åˆ°è¿™ä¸ªçš„äººå¯èƒ½çœ‹ä¸æ‡‚è¿™é‡Œçš„ä»£ç ï¼Œå¸Œæœ›ä½ æ—©æ—¥èƒ½åœ¨åˆ«çš„åœ°æ–¹çœ‹æ‡‚ã€‚

## ç€è‰²å™¨
å¦‚æœå–œæ¬¢å›°éš¾çš„äººï¼Œé‚£ä¹ˆè¿™é‡Œå°±æ˜¯æœ€æœ‰æ„æ€çš„ä¸€èŠ‚ã€‚ç€è‰²å™¨æ˜¯ä¸€é—¨å•ç‹¬çš„è¯­è¨€â€”â€”`WGSL`ã€‚ç”±äºå…¶å£°æ˜éƒ½è¦æŒ‡å®šç±»å‹ï¼Œæ‰€ä»¥å®ƒç»™æˆ‘çš„æ„Ÿè§‰å¾ˆåƒé‚£äº›é«˜çº§è¯­è¨€â€”â€”åŸå§‹åˆä¸¥è°¨ã€‚ç€è‰²å™¨åˆ†ä¸ºä¸‰ç§ï¼š`é¡¶ç‚¹ç€è‰²å™¨ï¼Œç‰‡å…ƒç€è‰²å™¨ï¼Œè®¡ç®—ç€è‰²å™¨`ã€‚

é¡¶ç‚¹ç€è‰²å™¨è´Ÿè´£å¤„ç†é¡¶ç‚¹æ•°æ®ï¼Œç‰‡å…ƒç€è‰²å™¨è´Ÿè´£è®¡ç®—é¢œè‰²ã€‚è®¡ç®—ç€è‰²å™¨åˆ™å•çº¯å¾ˆå¤šï¼Œä¸ºå¼€å‘è€…æä¾›äº†ä¸€ä¸ªå¹¶è¡Œè®¡ç®—çš„å…¥å£ã€‚æ¯•ç«Ÿé¡¶ç‚¹ç€è‰²å™¨å’Œç‰‡å…ƒç€è‰²å™¨éƒ½æ˜¯è¦åœ¨æ¸²æŸ“æµæ°´çº¿é‡Œå·¥ä½œçš„ã€‚

## æ¸²æŸ“æµæ°´çº¿
æ¸²æŸ“æµæ°´çº¿ä¸æ•°æ®çš„ä¼ è¾“ä»¥åŠç€è‰²å™¨å°±ç®€å•å¾ˆå¤šï¼Œå®ƒçš„ç›®çš„æ˜¯å°†æˆ‘ä»¬å‰æœŸå‡†å¤‡å¥½çš„æ•°æ®ä»¥åŠç€è‰²å™¨ä¼ é€’åˆ°GPUä¸­è¿›è¡Œè¿è¡Œã€‚æµç¨‹ä¸»è¦æ˜¯ï¼š
```ts
// 1.æ ¹æ®ä¹‹å‰å‡†å¤‡å¥½çš„æ•°æ®ï¼Œåˆ›å»ºä¸€ä¸ªæ¸²æŸ“æµæ°´çº¿
const cellPipeline = device.createRenderPipeline({
  label: 'Cell pipeline',
  layout: 'auto',
  vertex: {
    module: device.createShaderModule({
      label: 'Vertex shader',
      code: vert
    }),
    entryPoint: 'vertexMain',
    buffers: [
      {
        arrayStride: 8,
        attributes: [
          {
            format: 'float32x2',
            offset: 0,
            shaderLocation: 0
          }
        ]
      }
    ]
  },
  fragment: {
    module: device.createShaderModule({
      label: 'Fragment shader',
      code: `@fragment
            fn fragmentMain() -> @location(0) vec4f {
              return vec4f(0,0,0.8,1);
            }`
    }),
    entryPoint: 'fragmentMain',
    targets: [
      {
        format: canvasFormat
      }
    ]
  }
})

// 2.åˆ›å»ºä¸€ä¸ªæ¸²æŸ“é€šé“ï¼Œå¹¶è®¾ç½®ç›¸å…³å‚æ•°
const pass = encoder.beginRenderPass({
  colorAttachments: [
    {
      view: ctx!.getCurrentTexture().createView(),
      loadOp: 'clear',
      clearValue: { r: 0, g: 0, b: 0.4, a: 1.0 },
      storeOp: 'store'
    }
  ]
})
// 3.è®¾ç½®æ¸²æŸ“æµæ°´çº¿
pass.setPipeline(cellPipeline)
// 4.è®¾ç½®ç»‘å®šç»„
pass.setBindGroup(0, bindGroups[step % 2])
// 5.è®¾ç½®é¡¶ç‚¹ç¼“å†²åŒº
pass.setVertexBuffer(0, vertexBuffer)
// 6.ç»˜åˆ¶
pass.draw(vertices.length / 2, GRID_SIZE * GRID_SIZE) // 6 vertices
// 7.ç»“æŸæ¸²æŸ“é€šé“
pass.end()
// 8.å®Œæˆæ¸²æŸ“é€šé“
const commandBuffer = encoder.finish()
// 9.æäº¤æ¸²æŸ“é€šé“
device.queue.submit([commandBuffer])
```
çœ‹èµ·æ¥å¥½åƒæŒºè‰ç‡çš„æ ·å­ğŸ‘€ã€‚
## ä»£ç å®ç°Game Of Life

### å†æ¬¡æ¼”ç¤º

<Demo />

### å®Œæ•´ä»£ç 
#### demo.tsx
```ts
'use client'

import { useLayoutEffect, useRef } from 'react'
// @ts-expect-error: TypeScript cannot resolve .wgsl files, but this is handled by the build system.
import shaderString from './shader.wgsl'
// @ts-expect-error: TypeScript cannot resolve .wgsl files, but this is handled by the build system.
import computedShaderString from './computed.wgsl'

export default function DemoRect() {
  const canvasRef = useRef<HTMLCanvasElement>(null)

  useLayoutEffect(() => {
    if (!canvasRef.current) return
    const init = async () => {
      const canvas = canvasRef.current!
      const ctx = canvas.getContext('webgpu')
      if (!ctx) return
      const adapter = await navigator.gpu.requestAdapter()
      const device = await adapter!.requestDevice()
      const canvasFormat = navigator.gpu.getPreferredCanvasFormat()
      ctx.configure({
        device: device,
        format: canvasFormat
      })

      const GRID_SIZE = 32
      let step = 0
      const UPDATE_INTERVAL = 20
      const vertices = new Float32Array([
        -0.8, -0.8, 0.8, -0.8, 0.8, 0.8, -0.8, -0.8, 0.8, 0.8, -0.8, 0.8
      ])
      const vertexBuffer = device.createBuffer({
        // å˜é‡å
        label: 'Cell vertices',
        // æ‰€éœ€è¦çš„å†…å­˜å¤§å°ï¼Œå¹¶ä¸æ„å‘³ç€è¦ä¸é¡¶ç‚¹æ•°æ®ç›¸åŒï¼Œåªæ˜¯æˆ‘ä»¬åªç”¨åˆ°è¿™äº›ã€‚
        size: vertices.byteLength,
        // ç¼“å†²åŒºçš„ç”¨æ³•ï¼Œä¸è¯¦è§£ï¼Œè¿™é‡Œæ˜¯æŒ‡è¯¥ç¼“å†²åŒºç”¨äºé¡¶ç‚¹æ•°æ®åŒæ—¶æ•°æ®å¯ä»¥å¤åˆ¶åˆ°å…¶ä¸­
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
      })

      device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/ 0, vertices)

      const uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE])
      const uniformBuffer = device.createBuffer({
        label: 'Grid Uniforms',
        size: uniformArray.byteLength,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      })
      device.queue.writeBuffer(uniformBuffer, 0, uniformArray)

      const shader = device.createShaderModule({
        label: 'Shader',
        code: shaderString
      })
      const cellStateArray = new Uint32Array(GRID_SIZE * GRID_SIZE)
      const cellStateStorage = [
        device.createBuffer({
          label: 'Cell State A',
          size: cellStateArray.byteLength,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
        }),
        device.createBuffer({
          label: 'Cell State B',
          size: cellStateArray.byteLength,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
        })
      ]
      for (let i = 0; i < cellStateArray.length; ++i) {
        cellStateArray[i] = Math.random() > 0.6 ? 1 : 0
      }
      device.queue.writeBuffer(cellStateStorage[0], 0, cellStateArray)
      for (let i = 0; i < cellStateArray.length; i++) {
        cellStateArray[i] = i % 2
      }
      device.queue.writeBuffer(cellStateStorage[1], 0, cellStateArray)
      // Create a bind group to pass the grid uniforms into the pipeline
      const bindGroupLayout = device.createBindGroupLayout({
        label: 'Cell Bind Group Layout',
        entries: [
          {
            binding: 0,
            visibility:
              GPUShaderStage.VERTEX |
              GPUShaderStage.COMPUTE |
              GPUShaderStage.FRAGMENT,
            buffer: {} // Grid uniform buffer
          },
          {
            binding: 1,
            visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
            buffer: { type: 'read-only-storage' } // Cell state input buffer
          },
          {
            binding: 2,
            visibility: GPUShaderStage.COMPUTE,
            buffer: { type: 'storage' } // Cell state output buffer
          }
        ]
      })
      const bindGroups = [
        device.createBindGroup({
          label: 'Cell renderer bind group A',
          layout: bindGroupLayout, // Updated Line
          entries: [
            {
              binding: 0,
              resource: { buffer: uniformBuffer }
            },
            {
              binding: 1,
              resource: { buffer: cellStateStorage[0] }
            },
            {
              binding: 2, // New Entry
              resource: { buffer: cellStateStorage[1] }
            }
          ]
        }),
        device.createBindGroup({
          label: 'Cell renderer bind group B',
          layout: bindGroupLayout, // Updated Line

          entries: [
            {
              binding: 0,
              resource: { buffer: uniformBuffer }
            },
            {
              binding: 1,
              resource: { buffer: cellStateStorage[1] }
            },
            {
              binding: 2, // New Entry
              resource: { buffer: cellStateStorage[0] }
            }
          ]
        })
      ]
      const simulationShaderModule = device.createShaderModule({
        label: 'Game of Life simulation shader',
        code: computedShaderString
      })
      const pipelineLayout = device.createPipelineLayout({
        label: 'Cell Pipeline Layout',
        bindGroupLayouts: [bindGroupLayout]
      })
      // Create a compute pipeline that updates the game state.
      const simulationPipeline = device.createComputePipeline({
        label: 'Simulation pipeline',
        layout: pipelineLayout,
        compute: {
          module: simulationShaderModule,
          entryPoint: 'computeMain'
        }
      })
      const cellPipeline = device.createRenderPipeline({
        label: 'Cell pipeline',
        layout: pipelineLayout,
        vertex: {
          module: shader,
          entryPoint: 'vertexMain',
          buffers: [
            {
              arrayStride: 8,
              attributes: [
                {
                  format: 'float32x2',
                  offset: 0,
                  shaderLocation: 0
                }
              ]
            }
          ]
        },
        fragment: {
          module: shader,
          entryPoint: 'fragmentMain',
          targets: [
            {
              format: canvasFormat
            }
          ]
        }
      })
      step++
      function updateGrid() {
        step++
        const encoder = device.createCommandEncoder()
        const computePass = encoder.beginComputePass()
        computePass.setPipeline(simulationPipeline)
        computePass.setBindGroup(0, bindGroups[step % 2])
        const workgroupCount = Math.ceil(GRID_SIZE / 8)
        computePass.dispatchWorkgroups(workgroupCount, workgroupCount)
        computePass.end()
        const pass = encoder.beginRenderPass({
          colorAttachments: [
            {
              view: ctx!.getCurrentTexture().createView(),
              loadOp: 'clear',
              clearValue: { r: 0, g: 0, b: 0.4, a: 1.0 },
              storeOp: 'store'
            }
          ]
        })
        pass.setPipeline(cellPipeline)
        pass.setBindGroup(0, bindGroups[step % 2])
        pass.setVertexBuffer(0, vertexBuffer)
        pass.draw(vertices.length / 2, GRID_SIZE * GRID_SIZE) // 6 vertices
        pass.end()
        const commandBuffer = encoder.finish()
        device.queue.submit([commandBuffer])
      }
      updateGrid()
      setInterval(updateGrid, UPDATE_INTERVAL)
    }
    init()
  })

  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        minHeight: '60vh',
        padding: '20px'
      }}
    >
      <canvas ref={canvasRef} width={400} height={400} style={{}} />
    </div>
  )
}
```
#### shader.wgsl
```ts
struct VertexInput {
  @location(0) pos : vec2f,
  @builtin(instance_index) instance : u32,
};

struct VertexOutput {
  @builtin(position) pos : vec4f,
  @location(0) cell : vec2f,//New line!
};

@group(0) @binding(0) var<uniform> grid : vec2f;
@group(0) @binding(1) var<storage> cellState: array<u32>;
@vertex
fn vertexMain(@location(0) pos: vec2f,
              @builtin(instance_index) instance: u32) -> VertexOutput {
  let i = f32(instance);
  let cell = vec2f(i % grid.x, floor(i / grid.x));
  let state = f32(cellState[instance]); // New line!

  let cellOffset = cell / grid * 2;
  // New: Scale the position by the cell's active state.
  let gridPos = (pos*state+1) / grid - 1 + cellOffset;

  var output: VertexOutput;
  output.pos = vec4f(gridPos, 0, 1);
  output.cell = cell;
  return output;
}

@fragment
fn fragmentMain(input : VertexOutput) -> @location(0) vec4f {
  let c = input.cell / grid;
  return vec4f(c, 1 - c.x, 1);
}
```
#### computed.wgsl
```ts
@group(0) @binding(0) var<uniform> grid : vec2f;

@group(0) @binding(1) var<storage> cellStateIn : array<u32>;
@group(0) @binding(2) var<storage, read_write> cellStateOut : array<u32>;

fn cellIndex(cell : vec2u) -> u32 {
  return (cell.y % u32(grid.y)) * u32(grid.x) +
  (cell.x % u32(grid.x));
}

fn cellActive(x : u32, y : u32) -> u32 {
  return cellStateIn[cellIndex(vec2(x, y))];
}

@compute @workgroup_size(8, 8)
fn computeMain(@builtin(global_invocation_id) cell : vec3u)
{
  let activeNeighbors = cellActive(cell.x + 1, cell.y + 1) +
  cellActive(cell.x + 1, cell.y) +
  cellActive(cell.x + 1, cell.y - 1) +
  cellActive(cell.x, cell.y - 1) +
  cellActive(cell.x - 1, cell.y - 1) +
  cellActive(cell.x - 1, cell.y) +
  cellActive(cell.x - 1, cell.y + 1) +
  cellActive(cell.x, cell.y + 1);
  
  let i = cellIndex(cell.xy);

      //Conway's game of life rules:
  switch activeNeighbors {
    case 2 : {
      cellStateOut[i] = cellStateIn[i];
    }
    case 3 : {
      cellStateOut[i] = 1;
    }
    default : {
      cellStateOut[i] = 0;
    }
  }
}
```